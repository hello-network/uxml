package com.hello.uxml.tools.codegen.emit.as3;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.hello.uxml.tools.codegen.emit.BooleanSerializer;
import com.hello.uxml.tools.codegen.emit.BorderRadiusSerializer;
import com.hello.uxml.tools.codegen.emit.ClassBuilder;
import com.hello.uxml.tools.codegen.emit.CodeSerializer;
import com.hello.uxml.tools.codegen.emit.CommandSerializer;
import com.hello.uxml.tools.codegen.emit.DoubleSerializer;
import com.hello.uxml.tools.codegen.emit.FunctionBuilder;
import com.hello.uxml.tools.codegen.emit.IntegerSerializer;
import com.hello.uxml.tools.codegen.emit.LocationSerializer;
import com.hello.uxml.tools.codegen.emit.MarginSerializer;
import com.hello.uxml.tools.codegen.emit.MatrixSerializer;
import com.hello.uxml.tools.codegen.emit.MethodBuilder;
import com.hello.uxml.tools.codegen.emit.PackageBuilder;
import com.hello.uxml.tools.codegen.emit.PenSerializer;
import com.hello.uxml.tools.codegen.emit.SourceWriter;
import com.hello.uxml.tools.codegen.emit.StringSerializer;
import com.hello.uxml.tools.codegen.emit.TypeToken;
import com.hello.uxml.tools.codegen.emit.expressions.Expression;
import com.hello.uxml.tools.codegen.emit.expressions.ExpressionStatement;
import com.hello.uxml.tools.codegen.emit.expressions.MethodCall;
import com.hello.uxml.tools.codegen.emit.expressions.NameExpression;
import com.hello.uxml.tools.codegen.emit.expressions.NewObjectExpression;
import com.hello.uxml.tools.codegen.emit.expressions.PropertyExpression;
import com.hello.uxml.tools.codegen.emit.expressions.Reference;
import com.hello.uxml.tools.codegen.emit.expressions.SelfReferenceExpression;
import com.hello.uxml.tools.codegen.emit.expressions.SetFieldExpression;
import com.hello.uxml.tools.codegen.emit.expressions.Statement;
import com.hello.uxml.tools.codegen.emit.expressions.StaticMethodCall;
import com.hello.uxml.tools.codegen.emit.expressions.StringLiteralExpression;
import com.hello.uxml.tools.codegen.emit.expressions.VariableDefinitionStatement;

import java.io.File;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Map;

/**
 * Implements PackageBuilder for ActionScript3.
 *
 * Writes copyright and package name.
 * Outputs class definition using the {@link ClassBuilder} object.
 *
 * @author ferhat
 */
public class As3PackageBuilder implements PackageBuilder {
  private static final String AUTOGEN_MSG = "// This file was generated by UXML Compiler";
  private String packageName = "";
  private static final TypeToken TYPE_TOKEN_OBJECT = TypeToken.fromClass(Object.class);
  private static final String JAVA_FRAMEWORK_PREFIX = "com.hello.uxml.tools.framework";
  /** List of classes defined in package */
  private ArrayList<As3ClassBuilder> classList = new ArrayList<As3ClassBuilder>();

  /** List of imports */
  private ArrayList<TypeToken> imports = Lists.newArrayList();

  /** Registered serializers. Maps element type name to CodeSerializer */
  private static final Map<String, CodeSerializer>codeSerializers = Maps.newHashMap();

  static {
    // Register code serializers
    codeSerializers.put("Color", new As3ColorSerializer());
    codeSerializers.put("Command", new CommandSerializer());
    codeSerializers.put("Brush", new As3SolidBrushSerializer());
    codeSerializers.put("SolidBrush", new As3SolidBrushSerializer());
    codeSerializers.put("Pen", new PenSerializer());
    codeSerializers.put("Point", new As3PointSerializer());
    codeSerializers.put("VecPath", new As3PathSerializer());
    codeSerializers.put("double", new DoubleSerializer());
    codeSerializers.put("Double", new DoubleSerializer());
    codeSerializers.put("num", new DoubleSerializer());
    codeSerializers.put("bool", new BooleanSerializer());
    codeSerializers.put("boolean", new BooleanSerializer());
    codeSerializers.put("Boolean", new BooleanSerializer());
    codeSerializers.put("String", new StringSerializer());
    codeSerializers.put("string", new StringSerializer());
    codeSerializers.put("int", new IntegerSerializer());
    codeSerializers.put("Integer", new IntegerSerializer());
    codeSerializers.put("Matrix", new MatrixSerializer());
    codeSerializers.put("Margin", new MarginSerializer());
    codeSerializers.put("BorderRadius", new BorderRadiusSerializer());
    codeSerializers.put("HAlign", new As3HAlignSerializer());
    codeSerializers.put("VAlign", new As3VAlignSerializer());
    codeSerializers.put("Dock", new As3DockSerializer());
    codeSerializers.put("ScaleMode", new As3ScaleModeSerializer());
    codeSerializers.put("Orientation", new As3OrientationSerializer());
    codeSerializers.put("BlendMode", new As3BlendModeSerializer());
    codeSerializers.put("LayoutType", new As3LayoutTypeSerializer());
    codeSerializers.put("Transition", new As3TransitionSerializer());
    codeSerializers.put("TextAlign", new As3TextAlignSerializer());
    codeSerializers.put("OverlayLocation", new LocationSerializer());
  }

  /**
   * Sets package name.
   */
  @Override
  public void setName(String name) {
    packageName = name;
  }

  @Override
  public void setPartName(String partName) {
  }

  /**
   * Returns package name.
   */
  @Override
  public String getName() {
    return packageName;
  }

  /**
   * Creates a ClassBuilder object and adds it to package.
   *
   * @param name Class name
   * @return builder for class members
   */
  @Override
  public ClassBuilder createClass(String name) {
    As3ClassBuilder classBuilder = new As3ClassBuilder(this, name);
    this.classList.add(classBuilder);
    return classBuilder;
  }

  /**
   * Adds a new namespace import.
   */
  @Override
  public void addImport(TypeToken type) {
    if (type.equals(TYPE_TOKEN_OBJECT)) {
      return;
    }
    if (!imports.contains(type)) {
      type = normalizeType(type);
      if (!imports.contains(type)) {
        String namespace = type.getNamespace();
        if ((namespace != null) && (namespace.length() != 0)) {
        imports.add(type);
        }
      }
    }
  }

  /**
   * Create SelfReferenceExpression instance.
   */
  @Override
  public SelfReferenceExpression createSelfReferenceExpression() {
    return new SelfReferenceExpression();
  }

  /**
   * Create method call.
   */
  @Override
  public MethodCall createMethodCall(Expression target, String methodName) {
    return new MethodCall(target, methodName);
  }

  /**
   * Creates dynamic late bound method call.
   */
  @Override
  public MethodCall createDynamicCall(Expression target, String methodName,
      Expression[] parameters, MethodBuilder method) {
    return new MethodCall(target, methodName, parameters);
  }

  /**
   * Create a method call to a static member function.
   */
  @Override
  public StaticMethodCall createStaticMethodCall(TypeToken targetType, String methodName) {
    return createStaticMethodCall(targetType, methodName, null);
  }

  @Override
  public StaticMethodCall createStaticMethodCall(TypeToken targetType, String methodName,
      Expression[] parameters) {
    return new As3StaticMethodCall(targetType, methodName, parameters);
  }


  /**
   * Creates a closure.
   */
  @Override
  public MethodBuilder createClosure(TypeToken returnType) {
    return new As3MethodBuilder(MethodBuilder.CLOSURE_NAME, returnType, null);
  }

  /**
   * Create set field expression.
   */
  @Override
  public SetFieldExpression createSetFieldExpression(Expression target, String fieldName,
      Expression rhs) {
    return new As3SetFieldExpression(target, fieldName, rhs);
  }

  /**
   * Create get field expression.
   */
  @Override
  public Expression createGetFieldExpression(Expression target, String fieldName) {
    return new As3GetFieldExpression(target, fieldName);
  }

  /**
   * Creates a set static field expression.
   */
  @Override
  public SetFieldExpression createSetStaticFieldExpression(TypeToken type, String fieldName,
      Expression rhs) {
    return new As3SetFieldExpression(new Reference(type.getName()), fieldName, rhs);
  }

  /**
   * Creates a get static field expression.
   */
  @Override
  public Expression createGetStaticFieldExpression(TypeToken type, String fieldName) {
    return new As3GetFieldExpression(new Reference(type.getName()), fieldName);
  }

  /**
   * Create set property expression.
   */
  @Override
  public Expression createSetPropertyExpression(Expression target, String propertyName,
      Expression rhs) {
    return new As3SetPropertyExpression(target, propertyName, rhs);
  }

  /**
   * Create get property expression.
   */
  @Override
  public Expression createGetPropertyExpression(Expression target, String fieldName) {
    return new As3GetPropertyExpression(target, fieldName);
  }

  /**
   * Create method call.
   */
  @Override
  public MethodCall createMethodCall(Expression target, String methodName,
      Expression[] parameters) {
    return new MethodCall(target, methodName, parameters);
  }

  /**
   * Create a statement from an expression.
   */
  @Override
  public ExpressionStatement createExpressionStatement(Expression expression) {
    return new ExpressionStatement(expression);
  }

  /**
   * Create a local variable declaration.
   */
  @Override
  public VariableDefinitionStatement createVariableDefinition(Reference reference) {
    return new As3VariableDefinitionStatement(reference);
  }

  /**
   * Create a local variable declaration.
   */
  @Override
  public VariableDefinitionStatement createVariableDefinition(Reference reference,
      Expression expr) {
    return new As3VariableDefinitionStatement(reference, expr);
  }

  /**
   * Creates a StringLiteralExpression.
   */
  @Override
  public Expression createStringLiteralExpression(String value) {
    return new StringLiteralExpression(value);
  }


  /**
   * Creates a NewObjectExpression.
   */
  @Override
  public NewObjectExpression createNewObjectExpression(TypeToken type) {
    return new As3NewObjectExpression(type);
  }

  /**
   * Creates a NewObjectExpression.
   */
  @Override
  public NewObjectExpression createNewObjectExpression(TypeToken type, Expression[] parameters) {
    return new As3NewObjectExpression(type, parameters);
  }

  /**
   * Creates a NewObjectExpression.
   */
  @Override
  public NewObjectExpression createNewObjectExpression(TypeToken type, String ctorName,
      Expression[] parameters) {
    // TODO(ferhat): map generative constructors to static factory methods for actionscript.
    throw new IllegalArgumentException();
  }

  /**
   * @see PackageBuilder
   */
  @Override
  public Expression createClassReferenceExpression(TypeToken type) {
    return new As3ClassReferenceExpression(type);
  }

  /**
   * @see PackageBuilder
   */
  @Override
  public Expression createElementTypeReferenceExpression(TypeToken type) {
    return new As3ClassReferenceExpression(type);
  }

  /**
   * Creates a delegate (Flash function)
   */
  @Override
  public Expression createDelegate(Expression targetObject, String targetMethodName) {

    // The method field is of type Function that we can use as a delegate.
    return createGetFieldExpression(targetObject, targetMethodName);
  }

  /**
   * Creates a chrome handler delegate.
   */
  @Override
  public Expression createChromeDelegate(String targetMethodName) {
    // The method field is of type Function that we can use as a delegate.
    return new Reference(targetMethodName);
  }

  /**
   * @see PackageBuilder
   */
  @Override
  public Statement createCollectionAddStatement(Expression collection, Expression value) {
    return new As3CollectionAddStatement(collection, value);
  }

  /**
   * Creates an array object from a list of expressions.
   */
  @Override
  public Expression createArray(TypeToken arrayType, Expression[] values) {
    return new As3CreateArrayExpression(values);
  }

  /**
   * Creates a property expression for inside an object (ie {prop:value}).
   */
  @Override
  public Expression createPropertyExpression(NameExpression name,
      Expression rightExpression) {
    return new PropertyExpression(name, rightExpression);
  }

  /**
   * Creates expression to get array element.
   */
  @Override
  public Expression createGetArrayElementExpression(Expression array,
      Expression[] indices) {
    StringBuilder sb = new StringBuilder();
    sb.append(SourceWriter.toString(array));
    sb.append("[");
    for (int i = 0; i < indices.length; ++i) {
      if (i != 0) {
        sb.append(",");
      }
      sb.append(SourceWriter.toString(indices[i]));
    }
    sb.append("]");
    return new Reference(sb.toString());
  }


  /**
   * Creates a type cast expression.
   */
  @Override
  public Expression createTypeCast(TypeToken targetType, Expression expression) {
    return new As3TypeCastExpression(targetType, expression);
  }

  /**
   * Create a function
   */
  @Override
  public FunctionBuilder createNewFunction(String name, TypeToken returnType) {
    return new AS3FunctionBuilder(name, returnType);
  }

  /**
   * Translate primitive type names to target.
   */
  @Override
  public String tokenTypeToString(TypeToken type) {
    return As3FrameworkTypes.tokenTypeToString(type);
  }

  /**
   * Returns custom code serializers for primitive Hts types.
   */
  @Override
  public CodeSerializer getSerializer(TypeToken elementType) {
    return codeSerializers.get(elementType.getName());
  }

  /**
   * Output package and contents using SourceWriter.
   *
   * @return whether code generation succeeded
   */
  @Override
  public boolean write(SourceWriter writer) {
    writer.println(AUTOGEN_MSG);
    writer.printEmptyLine();
    if (packageName.length() == 0) {
      writer.println("package {");
    } else {
      writer.print("package ");
      writer.print(packageName);
      writer.println(" {");
    }
    writer.indent();
    for (TypeToken namespace : imports) {
      writer.print("import ");
      writer.print(namespace.getFullName());
      writer.println(";");
    }
    writer.outdent();
    writer.printEmptyLine();
    writer.indent();
    // For each class write out class members
    for (ClassBuilder classBuilder : classList) {
      classBuilder.write(writer);
    }
    writer.outdent();
    writer.println("}");

    return true;
  }

  /**
   * Converts type from internal type to target language.
   */
  @Override
  public TypeToken normalizeType(TypeToken type) {
    if (type == null) {
      return null;
    }
    String name = type.getFullName();
    if (name.startsWith(JAVA_FRAMEWORK_PREFIX)) {
        return TypeToken.fromFullName("com.google.uxml" + name.substring(
            JAVA_FRAMEWORK_PREFIX.length()));
    }
    return type;
  }

  /**
   * Returns default file extension.
   */
  @Override
  public String getDefaultFileExtension() {
    return "as";
  }

  /**
   * Returns language specific target directory for package name.
   *
   * Languages such as Dart don't have package names and use
   * import prefix instead.
   */
  @Override
  public String getFileTargetDir(String path, File uxmlFile, String packageName,
      File sourceRoot) {
    if (!path.endsWith(File.separator)) {
      path += File.separatorChar;
    }
    return path + packageName.replace('.', File.separatorChar);
  }

  /**
   * Returns true if language supports explicit casts.
   */
  @Override
  public boolean supportsExplicitCast() {
    return true;
  }

  /**
   * Returns property definition naming convention.
   */
  @Override
  public String getPropertyDefPostFix() {
    return "Property";
  }

  /**
   * @see PackageBuilder
   */
  @Override
  public Expression localizeLiteralString(String value) {
    return null;
  }

  @Override
  public Reference createReferenceExpression(String varName) {
    return new As3Reference(varName);
  }

  @Override
  public Reference createReferenceExpression(String varName, TypeToken type) {
    return new As3Reference(varName, type);
  }

  @Override
  public Reference createReferenceExpression(String varName, TypeToken type,
      Boolean includeType) {
    return new As3Reference(varName, type, includeType);
  }
}

