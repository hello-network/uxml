package com.hello.uxml.tools.codegen.emit.dart;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.hello.uxml.tools.framework.UxmlElement;
import com.hello.uxml.tools.codegen.emit.BooleanSerializer;
import com.hello.uxml.tools.codegen.emit.ClassBuilder;
import com.hello.uxml.tools.codegen.emit.CodeSerializer;
import com.hello.uxml.tools.codegen.emit.CommandSerializer;
import com.hello.uxml.tools.codegen.emit.DoubleSerializer;
import com.hello.uxml.tools.codegen.emit.FunctionBuilder;
import com.hello.uxml.tools.codegen.emit.GradientStopSerializer;
import com.hello.uxml.tools.codegen.emit.IntegerSerializer;
import com.hello.uxml.tools.codegen.emit.LocationSerializer;
import com.hello.uxml.tools.codegen.emit.MatrixSerializer;
import com.hello.uxml.tools.codegen.emit.MethodBuilder;
import com.hello.uxml.tools.codegen.emit.PackageBuilder;
import com.hello.uxml.tools.codegen.emit.PenSerializer;
import com.hello.uxml.tools.codegen.emit.SolidPenSerializer;
import com.hello.uxml.tools.codegen.emit.SourceWriter;
import com.hello.uxml.tools.codegen.emit.StringSerializer;
import com.hello.uxml.tools.codegen.emit.TypeToken;
import com.hello.uxml.tools.codegen.emit.as3.As3ColorSerializer;
import com.hello.uxml.tools.codegen.emit.as3.As3CreateArrayExpression;
import com.hello.uxml.tools.codegen.emit.as3.As3GetFieldExpression;
import com.hello.uxml.tools.codegen.emit.as3.As3GetPropertyExpression;
import com.hello.uxml.tools.codegen.emit.as3.As3HAlignSerializer;
import com.hello.uxml.tools.codegen.emit.as3.As3PathSerializer;
import com.hello.uxml.tools.codegen.emit.as3.As3PointSerializer;
import com.hello.uxml.tools.codegen.emit.as3.As3SetFieldExpression;
import com.hello.uxml.tools.codegen.emit.as3.As3SetPropertyExpression;
import com.hello.uxml.tools.codegen.emit.as3.As3SolidBrushSerializer;
import com.hello.uxml.tools.codegen.emit.as3.As3TextAlignSerializer;
import com.hello.uxml.tools.codegen.emit.as3.As3VAlignSerializer;
import com.hello.uxml.tools.codegen.emit.expressions.Expression;
import com.hello.uxml.tools.codegen.emit.expressions.ExpressionStatement;
import com.hello.uxml.tools.codegen.emit.expressions.MethodCall;
import com.hello.uxml.tools.codegen.emit.expressions.NameExpression;
import com.hello.uxml.tools.codegen.emit.expressions.NewObjectExpression;
import com.hello.uxml.tools.codegen.emit.expressions.Reference;
import com.hello.uxml.tools.codegen.emit.expressions.SelfReferenceExpression;
import com.hello.uxml.tools.codegen.emit.expressions.SetFieldExpression;
import com.hello.uxml.tools.codegen.emit.expressions.Statement;
import com.hello.uxml.tools.codegen.emit.expressions.StaticMethodCall;
import com.hello.uxml.tools.codegen.emit.expressions.StringLiteralExpression;
import com.hello.uxml.tools.codegen.emit.expressions.VariableDefinitionStatement;
import com.hello.uxml.tools.codegen.emit.java.JCollectionAddStatement;
import com.hello.uxml.tools.codegen.emit.java.JNewObjectExpression;
import com.hello.uxml.tools.codegen.emit.java.JStaticMethodCall;

import java.io.File;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Map;

/**
 * Implements PackageBuilder for Dart.
 *
 * Writes copyright and package name.
 * Outputs class definition using the {@link ClassBuilder} object.
 *
 * @author ferhat
 */
public class DartPackageBuilder implements PackageBuilder {
  private static final String AUTOGEN_MSG = "// This file was generated by UXML Compiler";
  private String packageName = "";
  private String partName = "";
  private static final TypeToken TYPE_TOKEN_OBJECT = TypeToken.fromClass(Object.class);

  /** List of classes defined in package */
  private ArrayList<DartClassBuilder> classList = new ArrayList<DartClassBuilder>();

  /** List of imports */
  private ArrayList<TypeToken> imports = Lists.newArrayList();

  /** Registered serializers. Maps element type name to CodeSerializer */
  private static final Map<String, CodeSerializer>codeSerializers = Maps.newHashMap();

  /** Common TypeTokens */

  static {
    // Register code serializers
    codeSerializers.put("Color", new As3ColorSerializer());
    codeSerializers.put("Command", new CommandSerializer());
    codeSerializers.put("Brush", new As3SolidBrushSerializer());
    codeSerializers.put("SolidBrush", new As3SolidBrushSerializer());
    codeSerializers.put("GradientStop", new GradientStopSerializer());
    codeSerializers.put("Point", new As3PointSerializer());
    codeSerializers.put("Pen", new PenSerializer());
    codeSerializers.put("VecPath", new As3PathSerializer());
    codeSerializers.put("double", new DoubleSerializer());
    codeSerializers.put("Double", new DoubleSerializer());
    codeSerializers.put("num", new DoubleSerializer());
    codeSerializers.put("bool", new BooleanSerializer());
    codeSerializers.put("boolean", new BooleanSerializer());
    codeSerializers.put("Boolean", new BooleanSerializer());
    codeSerializers.put("String", new StringSerializer());
    codeSerializers.put("string", new StringSerializer());
    codeSerializers.put("int", new IntegerSerializer());
    codeSerializers.put("Integer", new IntegerSerializer());
    codeSerializers.put("Matrix", new MatrixSerializer());
    codeSerializers.put("Margin", new DartMarginSerializer());
    codeSerializers.put("BorderRadius", new DartBorderRadiusSerializer());
    codeSerializers.put("SolidPen", new SolidPenSerializer());
    codeSerializers.put("HAlign", new As3HAlignSerializer());
    codeSerializers.put("VAlign", new As3VAlignSerializer());
    codeSerializers.put("TextAlign", new As3TextAlignSerializer());
    codeSerializers.put("OverlayLocation", new LocationSerializer());
  }

  /**
   * Sets package name.
   */
  @Override
  public void setName(String name) {
    packageName = name;
  }

  /**
   * Returns package name.
   */
  @Override
  public String getName() {
    return packageName;
  }

  /**
   * Sets library part name.
   */
  @Override
  public void setPartName(String partName) {
    this.partName = partName;
  }

  /**
   * Creates a ClassBuilder object and adds it to package.
   *
   * @param name Class name
   * @return builder for class members
   */
  @Override
  public ClassBuilder createClass(String name) {
    DartClassBuilder classBuilder = new DartClassBuilder(this, name);
    this.classList.add(classBuilder);
    return classBuilder;
  }

  /**
   * Adds a new namespace import.
   */
  @Override
  public void addImport(TypeToken type) {
    if (type.equals(TYPE_TOKEN_OBJECT)) {
      return;
    }
    if (!imports.contains(type)) {
      String namespace = type.getNamespace();
      if ((namespace != null) && (namespace.length() != 0)) {
      imports.add(type);
      }
    }
  }

  /**
   * Create SelfReferenceExpression instance.
   */
  @Override
  public SelfReferenceExpression createSelfReferenceExpression() {
    return new SelfReferenceExpression();
  }

  /**
   * Create method call.
   */
  @Override
  public MethodCall createMethodCall(Expression target, String methodName) {
    return new MethodCall(target, methodName);
  }

  /**
   * Creates dynamic late bound method call.
   */
  @Override
  public MethodCall createDynamicCall(Expression target, String methodName,
      Expression[] parameters, MethodBuilder method) {
    return new DartDynamicMethodCall(target, methodName, parameters, method);
  }

  /**
   * Create a method call to a static member function.
   */
  @Override
  public StaticMethodCall createStaticMethodCall(TypeToken targetType, String methodName) {
    return createStaticMethodCall(targetType, methodName, null);
  }

  /**
   * Create a method call to a static member function.
   */
  @Override
  public StaticMethodCall createStaticMethodCall(TypeToken targetType, String methodName,
      Expression[] parameters) {
    return new JStaticMethodCall(targetType, methodName, parameters);
  }

  /**
   * Creates a closure.
   */
  @Override
  public MethodBuilder createClosure(TypeToken returnType) {
    return new DartClosure(MethodBuilder.CLOSURE_NAME, returnType, this, null);
  }

  /**
   * Create set field expression.
   */
  @Override
  public SetFieldExpression createSetFieldExpression(Expression target, String fieldName,
      Expression rhs) {
    return new As3SetFieldExpression(target, fieldName, rhs);
  }

  /**
   * Create get field expression.
   */
  @Override
  public Expression createGetFieldExpression(Expression target, String fieldName) {
    return new As3GetFieldExpression(target, fieldName);
  }

  /**
   * Creates a set static field expression.
   */
  @Override
  public SetFieldExpression createSetStaticFieldExpression(TypeToken type, String fieldName,
      Expression rhs) {
    return new As3SetFieldExpression(new Reference(type.getName()), fieldName, rhs);
  }

  /**
   * Creates a get static field expression.
   */
  @Override
  public Expression createGetStaticFieldExpression(TypeToken type, String fieldName) {
    if (type.getFullName().equals(UxmlElement.class.getName())) {
      return new As3GetFieldExpression(new Reference("UxmlElement"), fieldName);
    }
    return new As3GetFieldExpression(new Reference(DartFrameworkTypes.tokenTypeToString(type)),
        fieldName);
  }

  /**
   * Create get property expression.
   */
  @Override
  public Expression createGetPropertyExpression(Expression target, String propertyName) {
    return new As3GetPropertyExpression(target, propertyName);
  }

  /**
   * Create set property expression.
   */
  @Override
  public Expression createSetPropertyExpression(Expression target, String propertyName,
      Expression rhs) {
    return new As3SetPropertyExpression(target, propertyName, rhs);
  }


  /**
   * Create method call.
   */
  @Override
  public MethodCall createMethodCall(Expression target, String methodName,
      Expression[] parameters) {
    return new MethodCall(target, methodName, parameters);
  }

  /**
   * Create a statement from an expression.
   */
  @Override
  public ExpressionStatement createExpressionStatement(Expression expression) {
    return new ExpressionStatement(expression);
  }

  /**
   * Create a local variable declaration.
   */
  @Override
  public VariableDefinitionStatement createVariableDefinition(Reference reference) {
    return new DartVariableDefinitionStatement(reference);
  }

  /**
   * Create a local variable declaration.
   */
  @Override
  public VariableDefinitionStatement createVariableDefinition(Reference reference,
      Expression expr) {
    return new DartVariableDefinitionStatement(reference, expr);
  }

  /**
   * Creates a StringLiteralExpression.
   */
  @Override
  public Expression createStringLiteralExpression(String value) {
    return new StringLiteralExpression(value);
  }

  /**
   * Creates a NewObjectExpression.
   */
  @Override
  public NewObjectExpression createNewObjectExpression(TypeToken type) {
    type = fixDartType(type);
    return new JNewObjectExpression(type);
  }

  /**
   * Creates a NewObjectExpression.
   */
  @Override
  public NewObjectExpression createNewObjectExpression(TypeToken type, Expression[] parameters) {
    type = fixDartType(type);
    return new DartNewObjectExpression(type, "", parameters);
  }

  /**
   * Creates a NewObjectExpression with a named constructor. See generative constructors
   * in Dart language spec.
   */
  @Override
  public NewObjectExpression createNewObjectExpression(TypeToken type, String constructorName,
      Expression[] parameters) {
    type = fixDartType(type);
    return new DartNewObjectExpression(type, constructorName, parameters);
  }

  private TypeToken fixDartType(TypeToken type) {
    if (type.getName().equals("Point")) {
      return TypeToken.fromFullName("com.hello.uxml.tools.framework.Coord");
    }
    if (type.getName().equals("Transform")) {
      return TypeToken.fromFullName("com.hello.uxml.tools.framework.UITransform");
    }
    return type;
  }

  /**
   * @see PackageBuilder
   */
  @Override
  public Expression createClassReferenceExpression(TypeToken type) {
    // TODO(ferhat): change this once Dart language has mirror reflection.
    return createElementTypeReferenceExpression(type);
  }

  /**
   * @see PackageBuilder
   */
  @Override
  public Expression createElementTypeReferenceExpression(TypeToken type) {
    return createGetStaticFieldExpression(type, type.getName().toLowerCase() + "ElementDef");
  }

  /**
   * @see PackageBuilder
   */
  @Override
  public Statement createCollectionAddStatement(Expression collection, Expression value) {
    return new JCollectionAddStatement(collection, value);
  }

  /**
   * Creates an array object from a list of expressions.
   */
  @Override
  public Expression createArray(TypeToken arrayType, Expression[] values) {
    return new As3CreateArrayExpression(values);
  }

  /**
   * Creates a property expression for inside an object (ie {prop:value}).
   */
  @Override
  public Expression createPropertyExpression(NameExpression name,
      Expression rightExpression) {
    return new DartPropertyExpression(name, rightExpression);
  }

  /**
   * Creates expression to get array element.
   */
  @Override
  public Expression createGetArrayElementExpression(Expression array,
      Expression[] indices) {
    StringBuilder sb = new StringBuilder();
    sb.append(SourceWriter.toString(array));
    sb.append("[");
    for (int i = 0; i < indices.length; ++i) {
      if (i != 0) {
        sb.append(",");
      }
      sb.append(SourceWriter.toString(indices[i]));
    }
    sb.append("]");
    return new Reference(sb.toString());
  }

  /**
   * Creates a type cast expression.
   */
  @Override
  public Expression createTypeCast(TypeToken targetType, Expression expression) {
    return expression; // no type cast operator for dart.
  }

  /**
   * Creates a delegate (Dart function).
   */
  @Override
  public Expression createDelegate(Expression targetObject, String targetMethodName) {

    // The method field is of type Function that we can use as a delegate.
    return createGetFieldExpression(targetObject, targetMethodName);
  }

  /**
   * Creates a chrome handler delegate.
   */
  @Override
  public Expression createChromeDelegate(String targetMethodName) {
    // The method field is of type Function that we can use as a delegate.
    return new Reference(targetMethodName);
  }


  /**
   * Translate primitive type names to target.
   */
  @Override
  public String tokenTypeToString(TypeToken type) {
    return DartFrameworkTypes.tokenTypeToString(type);
  }

  /**
   * Returns custom code serializers for primitive Hts types.
   */
  @Override
  public CodeSerializer getSerializer(TypeToken elementType) {
    CodeSerializer serializer = codeSerializers.get(elementType.getName());
    if (serializer != null) {
      return serializer;
    }
    // Check if type is enum and cache code serializer for it.
    if ((elementType.getNamespace() != null) && (elementType.getNamespace().length() != 0)) {
      Class<?> elementClass = null;
      try {
        elementClass = Class.forName(elementType.getFullName());
      } catch (ClassNotFoundException e) {
        elementClass = null;
      }
      if ((elementClass != null) && elementClass.isEnum()) {
        serializer = new DartEnumSerializer(elementClass);
        codeSerializers.put(elementType.getName(), serializer);
      }
    }
    return serializer;
  }

  /**
   * Output package and contents using SourceWriter.
   *
   * @return whether code generation succeeded
   */
  @Override
  public boolean write(SourceWriter writer) {
    if (partName != null && partName.length() != 0) {
      writer.print("part of ");
      writer.print(partName);
      writer.println(";");
    }
    writer.println(AUTOGEN_MSG);
    writer.printEmptyLine();
    // Write package name
    if (packageName.length() == 0) {
      writer.println("/** !package ; */");
    } else {
      writer.print("/** !package ");
      writer.print(packageName);
      writer.println("; */");
    }
    writer.printEmptyLine();

    // For each class write out class members
    for (ClassBuilder classBuilder : classList) {
      classBuilder.write(writer);
    }
    return true;
  }

  /**
   * Returns default file extension.
   */
  @Override
  public String getDefaultFileExtension() {
    return "g.dart";
  }

  /**
   * Returns language specific target directory for package name.
   *
   * Languages such as Dart don't have package names and use
   * import prefix instead.
   */
  @Override
  public String getFileTargetDir(String path, File uxmlFile, String packageName,
      File sourceRoot) {
    if (sourceRoot != null && sourceRoot.length() != 0) {
      return path; // Not compiling in plugin context, path already is set by cmdline.
    }
    if (!path.endsWith(File.separator)) {
      path += File.separatorChar;
    }
    return path + packageName.replace('.', File.separatorChar);
  }

  /**
   * Converts type from internal type to target language.
   */
  @Override
  public TypeToken normalizeType(TypeToken type) {
    return type;
  }

  /**
   * Creates a new function.
   */
  @Override
  public FunctionBuilder createNewFunction(String name, TypeToken returnType) {
    return new DartFunctionBuilder(name, returnType);
  }

  /**
   * Returns true if language supports explicit casts.
   */
  @Override
  public boolean supportsExplicitCast() {
    return false;
  }

  @Override
  public String getPropertyDefPostFix() {
    return "Property";
  }

  /**
   * @see PackageBuilder
   */
  @Override
  public Expression localizeLiteralString(String str) {
    // Returns markup value.
    if (str.startsWith("%%")) {
      str = str.substring(1);
    } else if (str.startsWith("%")) {
      int pos = str.indexOf('=');
      if (pos != -1) {
        str = str.substring(pos + 1);
      }
    }
    return new StringLiteralExpression(str);
  }

  @Override
  public Reference createReferenceExpression(String varName) {
    return new DartReference(varName);
  }

  @Override
  public Reference createReferenceExpression(String varName, TypeToken type) {
    return new DartReference(varName, type);
  }

  @Override
  public Reference createReferenceExpression(String varName, TypeToken type,
      Boolean includeType) {
    return new DartReference(varName, type, includeType);
  }
}
