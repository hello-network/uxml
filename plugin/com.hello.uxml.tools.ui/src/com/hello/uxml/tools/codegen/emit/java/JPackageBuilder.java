package com.hello.uxml.tools.codegen.emit.java;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.hello.uxml.tools.framework.UIElement;
import com.hello.uxml.tools.framework.events.ChromeHandler;
import com.hello.uxml.tools.framework.events.EventArgs;
import com.hello.uxml.tools.framework.events.EventHandler;
import com.hello.uxml.tools.framework.events.EventNotifier;
import com.hello.uxml.tools.codegen.emit.BooleanSerializer;
import com.hello.uxml.tools.codegen.emit.BorderRadiusSerializer;
import com.hello.uxml.tools.codegen.emit.ClassBuilder;
import com.hello.uxml.tools.codegen.emit.CodeSerializer;
import com.hello.uxml.tools.codegen.emit.CommandSerializer;
import com.hello.uxml.tools.codegen.emit.DoubleSerializer;
import com.hello.uxml.tools.codegen.emit.FunctionBuilder;
import com.hello.uxml.tools.codegen.emit.IntegerSerializer;
import com.hello.uxml.tools.codegen.emit.LocationSerializer;
import com.hello.uxml.tools.codegen.emit.MarginSerializer;
import com.hello.uxml.tools.codegen.emit.MatrixSerializer;
import com.hello.uxml.tools.codegen.emit.MethodBuilder;
import com.hello.uxml.tools.codegen.emit.PackageBuilder;
import com.hello.uxml.tools.codegen.emit.PenSerializer;
import com.hello.uxml.tools.codegen.emit.SourceWriter;
import com.hello.uxml.tools.codegen.emit.StringSerializer;
import com.hello.uxml.tools.codegen.emit.TypeToken;
import com.hello.uxml.tools.codegen.emit.as3.As3ClassReferenceExpression;
import com.hello.uxml.tools.codegen.emit.as3.As3ColorSerializer;
import com.hello.uxml.tools.codegen.emit.as3.As3GetFieldExpression;
import com.hello.uxml.tools.codegen.emit.as3.As3PathSerializer;
import com.hello.uxml.tools.codegen.emit.as3.As3PointSerializer;
import com.hello.uxml.tools.codegen.emit.as3.As3SetFieldExpression;
import com.hello.uxml.tools.codegen.emit.as3.As3SolidBrushSerializer;
import com.hello.uxml.tools.codegen.emit.expressions.Expression;
import com.hello.uxml.tools.codegen.emit.expressions.ExpressionStatement;
import com.hello.uxml.tools.codegen.emit.expressions.MethodCall;
import com.hello.uxml.tools.codegen.emit.expressions.NameExpression;
import com.hello.uxml.tools.codegen.emit.expressions.NewObjectExpression;
import com.hello.uxml.tools.codegen.emit.expressions.PropertyExpression;
import com.hello.uxml.tools.codegen.emit.expressions.Reference;
import com.hello.uxml.tools.codegen.emit.expressions.SelfReferenceExpression;
import com.hello.uxml.tools.codegen.emit.expressions.SetFieldExpression;
import com.hello.uxml.tools.codegen.emit.expressions.Statement;
import com.hello.uxml.tools.codegen.emit.expressions.StaticMethodCall;
import com.hello.uxml.tools.codegen.emit.expressions.StringLiteralExpression;
import com.hello.uxml.tools.codegen.emit.expressions.VariableDefinitionStatement;

import java.io.File;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Map;

/**
 * Implements PackageBuilder for Java.
 *
 * Writes copyright and package name.
 * Outputs class definition using the {@link ClassBuilder} object.
 *
 * @author ferhat
 */
public class JPackageBuilder implements PackageBuilder {
  private static final String AUTOGEN_MSG = "// This file was generated by UXML Compiler";
  private String packageName = "";
  private static final TypeToken TYPE_TOKEN_OBJECT = TypeToken.fromClass(Object.class);

  /** List of classes defined in package */
  private ArrayList<JClassBuilder> classList = new ArrayList<JClassBuilder>();

  /** List of imports */
  private ArrayList<TypeToken> imports = Lists.newArrayList();

  /** Registered serializers. Maps element type name to CodeSerializer */
  private static final Map<String, CodeSerializer>codeSerializers = Maps.newHashMap();

  /** Common TypeTokens */
  private TypeToken delegateTypeToken = TypeToken.fromFullName(EventHandler.class.getName());
  private TypeToken eventArgsTypeToken = TypeToken.fromFullName(EventArgs.class.getName());
  private TypeToken eventNotifierTypeToken = TypeToken.fromFullName(EventNotifier.class.getName());
  private TypeToken uiElementTypeToken = TypeToken.fromFullName(UIElement.class.getName());
  private TypeToken chromeHandlerTypeToken = TypeToken.fromFullName(ChromeHandler.class.getName());

  static {
    // Register code serializers
    codeSerializers.put("Color", new As3ColorSerializer());
    codeSerializers.put("Command", new CommandSerializer());
    codeSerializers.put("Brush", new As3SolidBrushSerializer());
    codeSerializers.put("SolidBrush", new As3SolidBrushSerializer());
    codeSerializers.put("Point", new As3PointSerializer());
    codeSerializers.put("Pen", new PenSerializer());
    codeSerializers.put("VecPath", new As3PathSerializer());
    codeSerializers.put("double", new DoubleSerializer());
    codeSerializers.put("Double", new DoubleSerializer());
    codeSerializers.put("num", new DoubleSerializer());
    codeSerializers.put("bool", new BooleanSerializer());
    codeSerializers.put("boolean", new BooleanSerializer());
    codeSerializers.put("Boolean", new BooleanSerializer());
    codeSerializers.put("String", new StringSerializer());
    codeSerializers.put("string", new StringSerializer());
    codeSerializers.put("int", new IntegerSerializer());
    codeSerializers.put("Integer", new IntegerSerializer());
    codeSerializers.put("Matrix", new MatrixSerializer());
    codeSerializers.put("Margin", new MarginSerializer());
    codeSerializers.put("BorderRadius", new BorderRadiusSerializer());
    codeSerializers.put("OverlayLocation", new LocationSerializer());
  }

  /**
   * Sets package name.
   */
  @Override
  public void setName(String name) {
    packageName = name;
  }

  /**
   * Returns package name.
   */
  @Override
  public String getName() {
    return packageName;
  }

  /**
   * Sets library part name.
   */
  @Override
  public void setPartName(String partName) {
    // Ignore. Not used.
  }

  /**
   * Creates a ClassBuilder object and adds it to package.
   *
   * @param name Class name
   * @return builder for class members
   */
  @Override
  public ClassBuilder createClass(String name) {
    JClassBuilder classBuilder = new JClassBuilder(this, name);
    this.classList.add(classBuilder);
    return classBuilder;
  }

  /**
   * Adds a new namespace import.
   */
  @Override
  public void addImport(TypeToken type) {
    if (type.equals(TYPE_TOKEN_OBJECT)) {
      return;
    }
    if (!imports.contains(type)) {
      String namespace = type.getNamespace();
      if ((namespace != null) && (namespace.length() != 0)) {
      imports.add(type);
      }
    }
  }

  /**
   * Create SelfReferenceExpression instance.
   */
  @Override
  public SelfReferenceExpression createSelfReferenceExpression() {
    return new SelfReferenceExpression();
  }

  /**
   * Create method call.
   */
  @Override
  public MethodCall createMethodCall(Expression target, String methodName) {
    return new MethodCall(target, methodName);
  }

  /**
   * Creates dynamic late bound method call.
   */
  @Override
  public MethodCall createDynamicCall(Expression target, String methodName,
      Expression[] parameters, MethodBuilder method) {
    return new JDynamicMethodCall(target, methodName, parameters, method);
  }

  /**
   * Create a method call to a static member function.
   */
  @Override
  public StaticMethodCall createStaticMethodCall(TypeToken targetType, String methodName) {
    return createStaticMethodCall(targetType, methodName, null);
  }

  /**
   * Create a method call to a static member function.
   */
  @Override
  public StaticMethodCall createStaticMethodCall(TypeToken targetType, String methodName,
      Expression[] parameters) {
    return new JStaticMethodCall(targetType, methodName, parameters);
  }

  /**
   * Creates a closure.
   */
  @Override
  public MethodBuilder createClosure(TypeToken returnType) {
    addImport(TypeToken.fromClass(EventNotifier.class));
    addImport(TypeToken.fromClass(EventHandler.class));
    addImport(TypeToken.fromClass(EventArgs.class));
    return new JClosure(MethodBuilder.CLOSURE_NAME, returnType, this, null);
  }

  /**
   * Create set field expression.
   */
  @Override
  public SetFieldExpression createSetFieldExpression(Expression target, String fieldName,
      Expression rhs) {
    return new JSetFieldExpression(target, fieldName, rhs);
  }

  /**
   * Create get field expression.
   */
  @Override
  public Expression createGetFieldExpression(Expression target, String fieldName) {
    return new JGetFieldExpression(target, fieldName);
  }

  /**
   * Creates a set static field expression.
   */
  @Override
  public SetFieldExpression createSetStaticFieldExpression(TypeToken type, String fieldName,
      Expression rhs) {
    return new As3SetFieldExpression(new Reference(type.getName()), fieldName, rhs);
  }

  /**
   * Creates a get static field expression.
   */
  @Override
  public Expression createGetStaticFieldExpression(TypeToken type, String fieldName) {
    return new As3GetFieldExpression(new Reference(type.getName()), fieldName);
  }

  /**
   * Create get property expression.
   */
  @Override
  public Expression createGetPropertyExpression(Expression target, String propertyName) {
    return new JGetPropertyExpression(target, propertyName);
  }

  /**
   * Create set property expression.
   */
  @Override
  public Expression createSetPropertyExpression(Expression target, String propertyName,
      Expression rhs) {
    return new JSetPropertyExpression(target, propertyName, rhs);
  }


  /**
   * Create method call.
   */
  @Override
  public MethodCall createMethodCall(Expression target, String methodName,
      Expression[] parameters) {
    return new MethodCall(target, methodName, parameters);
  }

  /**
   * Create a statement from an expression.
   */
  @Override
  public ExpressionStatement createExpressionStatement(Expression expression) {
    return new ExpressionStatement(expression);
  }

  /**
   * Create a local variable declaration.
   */
  @Override
  public VariableDefinitionStatement createVariableDefinition(Reference reference) {
    return new JVariableDefinitionStatement(reference);
  }

  /**
   * Create a local variable declaration.
   */
  @Override
  public VariableDefinitionStatement createVariableDefinition(Reference reference,
      Expression expr) {
    return new JVariableDefinitionStatement(reference, expr);
  }

  /**
   * Creates a StringLiteralExpression.
   */
  @Override
  public Expression createStringLiteralExpression(String value) {
    return new StringLiteralExpression(value);
  }

  /**
   * Creates a NewObjectExpression.
   */
  @Override
  public NewObjectExpression createNewObjectExpression(TypeToken type) {
    return new JNewObjectExpression(type);
  }

  /**
   * Creates a NewObjectExpression.
   */
  @Override
  public NewObjectExpression createNewObjectExpression(TypeToken type, Expression[] parameters) {
    return new JNewObjectExpression(type, parameters);
  }

  /**
   * Creates a NewObjectExpression.
   */
  @Override
  public NewObjectExpression createNewObjectExpression(TypeToken type, String ctorName,
      Expression[] parameters) {
    // TODO(ferhat): map generative constructors to static factory methods for java.
    throw new IllegalArgumentException();
  }

  /**
   * @see PackageBuilder
   */
  @Override
  public Expression createClassReferenceExpression(TypeToken type) {
    return new JClassReferenceExpression(type);
  }

  /**
   * @see PackageBuilder
   */
  @Override
  public Expression createElementTypeReferenceExpression(TypeToken type) {
    return new As3ClassReferenceExpression(type);
  }

  /**
   * @see PackageBuilder
   */
  @Override
  public Statement createCollectionAddStatement(Expression collection, Expression value) {
    return new JCollectionAddStatement(collection, value);
  }

  /**
   * Creates an array object from a list of expressions.
   */
  @Override
  public Expression createArray(TypeToken arrayType, Expression[] values) {
    return new JCreateArrayExpression(arrayType, values);
  }

  /**
   * Creates a property expression for inside an object (ie {prop:value}).
   */
  @Override
  public Expression createPropertyExpression(NameExpression name,
      Expression rightExpression) {
    return new PropertyExpression(name, rightExpression);
  }

  /**
   * Creates expression to get array element.
   */
  @Override
  public Expression createGetArrayElementExpression(Expression array,
      Expression[] indices) {
    StringBuilder sb = new StringBuilder();
    sb.append(SourceWriter.toString(array));
    sb.append("[");
    for (int i = 0; i < indices.length; ++i) {
      if (i != 0) {
        sb.append(",");
      }
      sb.append(SourceWriter.toString(indices[i]));
    }
    sb.append("]");
    return new Reference(sb.toString());
  }

  /**
   * Creates a type cast expression.
   */
  @Override
  public Expression createTypeCast(TypeToken targetType, Expression expression) {
    return new JTypeCastExpression(targetType, expression);
  }

  /**
   * Creates a delegate.
   * <p>A delegate in Java is an EventListener with handleEvent method that
   * calls the targetObject.method. Example:
   * button1.addListener(Button.clickEvent, new EventHandler() {
   *    public void handleEvent(EventNotifier target, EventArgs e) {
   *      loginController.onSignInClick((UIElement) target, e);
   *    }});
   */
  @Override
  public Expression createDelegate(Expression targetObject,
      String targetMethodName) {
    addImport(delegateTypeToken);
    addImport(eventNotifierTypeToken);
    addImport(eventArgsTypeToken);
    addImport(uiElementTypeToken);
    return new JEventListenerExpression(delegateTypeToken, targetObject, targetMethodName);
  }

  /**
   * Creates a chrome handler delegate.
   */
  @Override
  public Expression createChromeDelegate(String targetMethodName) {
    addImport(chromeHandlerTypeToken);
    addImport(uiElementTypeToken);
    return new JChromeDelegateExpression(targetMethodName);
  }


  /**
   * Translate primitive type names to target.
   */
  @Override
  public String tokenTypeToString(TypeToken type) {
    return JFrameworkTypes.tokenTypeToString(type);
  }

  /**
   * Returns custom code serializers for primitive Hts types.
   */
  @Override
  public CodeSerializer getSerializer(TypeToken elementType) {
    CodeSerializer serializer = codeSerializers.get(elementType.getName());
    if (serializer != null) {
      return serializer;
    }
    // Check if type is enum and cache code serializer for it.
    if ((elementType.getNamespace() != null) && (elementType.getNamespace().length() != 0)) {
      Class<?> elementClass = null;
      try {
        elementClass = Class.forName(elementType.getFullName());
      } catch (ClassNotFoundException e) {
        elementClass = null;
      }
      if ((elementClass != null) && elementClass.isEnum()) {
        serializer = new JEnumSerializer(elementClass);
        codeSerializers.put(elementType.getName(), serializer);
      }
    }
    return serializer;
  }

  /**
   * Output package and contents using SourceWriter.
   *
   * @return whether code generation succeeded
   */
  @Override
  public boolean write(SourceWriter writer) {
    writer.println(AUTOGEN_MSG);
    writer.printEmptyLine();
    // Write package name
    if (packageName.length() == 0) {
      writer.println("package ;");
    } else {
      writer.print("package ");
      writer.print(packageName);
      writer.println(";");
    }

    // write empty line between package and imports
    if (imports.size() != 0) {
      writer.printEmptyLine();
    }

    // write imports
    for (TypeToken namespace : imports) {
      writer.print("import ");
      writer.print(namespace.getFullName());
      writer.println(";");
    }
    writer.printEmptyLine();

    // For each class write out class members
    for (ClassBuilder classBuilder : classList) {
      classBuilder.write(writer);
    }
    return true;
  }

  /**
   * Returns default file extension.
   */
  @Override
  public String getDefaultFileExtension() {
    return "java";
  }

  /**
   * Returns language specific target directory for package name.
   *
   * Languages such as Dart don't have package names and use
   * import prefix instead.
   */
  @Override
  public String getFileTargetDir(String path, File uxmlFile, String packageName,
      File sourceRoot) {
    if (!path.endsWith(File.separator)) {
      path += File.separatorChar;
    }
    return path + packageName.replace('.', File.separatorChar);
  }

  /**
   * Converts type from internal type to target language.
   */
  @Override
  public TypeToken normalizeType(TypeToken type) {
    return type;
  }

  /**
   * Creates a new function.
   */
  @Override
  public FunctionBuilder createNewFunction(String name, TypeToken returnType) {
    // TODO(ericarnold): Fill in after creating JFunctionBuilder
    return null;
  }

  /**
   * Returns true if language supports explicit casts.
   */
  @Override
  public boolean supportsExplicitCast() {
    return true;
  }

  /**
   * Returns property definition naming convention.
   */
  @Override
  public String getPropertyDefPostFix() {
    return "PropDef";
  }

  /**
   * @see PackageBuilder
   */
  @Override
  public Expression localizeLiteralString(String value) {
    return null;
  }

  @Override
  public Reference createReferenceExpression(String varName) {
    return new JReference(varName);
  }

  @Override
  public Reference createReferenceExpression(String varName, TypeToken type) {
    return new JReference(varName, type);
  }

  @Override
  public Reference createReferenceExpression(String varName, TypeToken type,
      Boolean includeType) {
    return new JReference(varName, type, includeType);
  }

}
