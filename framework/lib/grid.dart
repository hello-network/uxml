part of uxml;

/**
 * Implements grid control.
 *
 * @author ferhat@ (Ferhat Buyukkokten)
 */
class Grid extends UIElementContainer {
  static ElementDef gridElementDef;

  /**
   * Holds gridrow definitions specified by grid user.
   */
  GridRows _externalRows;

  /**
   * Holds column definitions specified by grid user.
   */
  GridColumns _externalColumns;

  /**
   * Holds internal row collection to use for layout. It is generated by
   * measure/layout if externalRows is empty or is filled using externalRows.
   */
  List<GridRow> _gridRows;

  /**
   * Holds internal columns collection.
   */
  List<GridColumn> _gridColumns;

  // Register attached property definitions for Grid element.
  // The row and column index properties of child elements are set using
  // these properties. Since a child element such as button doesn't
  // have a property called row, column, these two properties are attached
  // to the child using the property system.
  /** Row Property Definition */
  static PropertyDefinition rowProperty;

  /** Column Property Definition */
  static PropertyDefinition columnProperty;

  /** Cellpadding property definition */
  static PropertyDefinition cellPaddingProperty;

  // Holds current layout size to detect relayout.
  num _prevGridWidth;
  num _prevGridHeight;
  num _cachedCellPadding;
  bool _gridDefsDirty;
  EventHandler _gridStructureChangedHandler;

  /**
   * Constructor.
   */
  Grid() : super() {
    _externalRows = new GridRows();
    _externalColumns = new GridColumns();
    _gridRows = null;
    _gridColumns = null;
    _gridDefsDirty = true;
    _gridStructureChangedHandler = _gridStructureChanged;
  }

  /**
   * Returns grid rows collection.
   */
  GridRows get rows => _externalRows;

  /**
   * Returns grid columns collection.
   */
  GridColumns get columns => _externalColumns;

  /** Gets or sets the cell padding */
  num get cellPadding => getProperty(cellPaddingProperty);

  set cellPadding(num value) {
    setProperty(cellPaddingProperty, value);
  }

  /** @see UIElement.initSurface. */
  void initSurface(UISurface parentSurface, [int index = -1]) {
    super.initSurface(parentSurface, index);
    if (_externalRows == null) {
      // reallocate when element is reused after close() call.
      _externalRows = new GridRows();
      _externalColumns = new GridColumns();
    }
    _externalRows.addListener(CollectionChangedEvent.eventDef,
        _gridStructureChangedHandler);
    _externalColumns.addListener(CollectionChangedEvent.eventDef,
        _gridStructureChangedHandler);
  }

  /** Overrides UIElement.close to cleanup. */
  void close() {
    super.close();
    _externalRows.removeListener(CollectionChangedEvent.eventDef,
        _gridStructureChangedHandler);
    _externalColumns.removeListener(CollectionChangedEvent.eventDef,
        _gridStructureChangedHandler);
    _externalRows = null;
    _externalColumns = null;
  }


  /**
   * Checks if grid layout needs to be recalculated.
   * @param availableWidth The max target area width available for grid.
   * @param availableHeight The target area height available for grid.
   */
  bool _isGridLayoutDirty(num availableWidth, num availableHeight) {
    return _gridDefsDirty || (_gridRows == null) || (_gridColumns == null) ||
      (_prevGridWidth != availableWidth) ||
      (_prevGridHeight != availableHeight);
  }

  /** Overrides UIElement.onMeasure to return size of element. */
  bool onMeasure(num availableWidth, num availableHeight) {
    _cachedCellPadding = cellPadding;
    if (_isGridLayoutDirty(availableWidth, availableHeight)) {
      _relayoutGrid(availableWidth, availableHeight);
      _gridDefsDirty = false;
    }
    num totalWidth = _computeFinalLayoutSize(_gridColumns);
    num totalHeight = _computeFinalLayoutSize(_gridRows);
    setMeasuredDimension(totalWidth, totalHeight);
    return false;
  }

  /**
   * Using the grid definition minLayoutSize, updates the position
   * and size of GridDefs.
   * @return Returns total minimum layout size.
   */
  num _computeFinalLayoutSize(List<GridDef> array) {
    num totalSize = 0.0;
    for (int i = 0; i < array.length; i++) {
      GridDef def = array[i];
      def.position = totalSize;
      def.size = def.minLayoutSize;
      totalSize += def.minLayoutSize;
    }
    return totalSize;
  }

  /** Overrides UIElement.onLayout. */
  void onLayout(num targetX, num targetY, num targetWidth, num targetHeight) {
    int numChildren = childCount;
    int row = 0;
    int column = 0;
    if (_isGridLayoutDirty(targetWidth, targetHeight)) {
      _relayoutGrid(targetWidth, targetHeight);
      _computeFinalLayoutSize(_gridColumns);
      _computeFinalLayoutSize(_gridRows);
    }

    for (int c = 0; c < numChildren; c++) {
      UIElement child = childElements[c];
      row = child.getProperty(rowProperty);
      column = child.getProperty(columnProperty);

      if (row > _gridRows.length) {
        row = _gridRows.length - 1;
      }

      if (column > _gridColumns.length) {
        column = _gridColumns.length - 1;
      }

      GridColumn gridCol = _gridColumns[column];
      GridRow gridRow = _gridRows[row];
      child.layout(gridCol.position + _cachedCellPadding, gridRow.position +
          _cachedCellPadding, gridCol.size - (_cachedCellPadding * 2),
          gridRow.size - (_cachedCellPadding * 2));
    }
  }

  /**
   * Prepares gridRows and gridColumns for grid layout. During the measure
   * step, the grid is asked for optimal size. Since this function is called
   * during final layout, the grid must fit the total area specified by
   * availableWidth/Height parameters otherwise contents will be clipped
   * against parent container depending on parent container clipping/mask
   * settings.
   * @param availableWidth maximum amount of horizontal space available for
   *  grid columns.
   * @param availableHeight maximum amount of vertical space available for
   *  grid rows.
   */
  void _relayoutGrid(num availableWidth, num availableHeight) {
    if (_gridRows == null) {
      _gridRows = <GridRow>[];
      if (_externalRows.length == 0) {
        // create at least 1 row and column if user didn't define any.
        _gridRows.add(new GridRow());
      } else {
        _externalRows.copyTo(_gridRows);
      }
    }

    if (_gridColumns == null) {
      _gridColumns = <GridColumn>[];
      if (_externalColumns.length == 0) {
        // create at least 1 row and column if user didn't define any.
        _gridColumns.add(new GridColumn());
      } else {
        _externalColumns.copyTo(_gridColumns);
      }
    }
    for (int c = 0; c < _gridColumns.length; c++) {
      _gridColumns[c].owner = this;
    }

    for (int r = 0; r < _gridRows.length; r++) {
      _gridRows[r].owner = this;
    }

    _calcFixedGridLayout(availableWidth, availableHeight);
    _prevGridWidth = availableWidth;
    _prevGridHeight = availableHeight;
  }

  /**
   * Calculates minLayoutSize and layoutSize for all columns and rows.
   */
  void _calcFixedGridLayout(num availableWidth, num availableHeight) {
    GridColumn column;
    GridRow row;
    int rowIndex = 0;
    int columnIndex = 0;

    // First setup minLayoutSize on all columns and rows.
    _initLayoutSizes(_gridColumns);
    _initLayoutSizes(_gridRows);

    _updateMinimumLayoutSize(LayoutType.AUTO | LayoutType.FIXED);

    _processPercentages(_gridColumns, availableWidth);
    _processPercentages(_gridRows, availableHeight);

    // We now have minLayoutSize and layoutSize calculated for each column and
    // row and can measure cells on percentage based columns/rows.
    _updateMinimumLayoutSize(LayoutType.PERCENT);
  }

  /**
   * Calculates total percentage, total fixed size and index of last column
   * and distributes extra space to columns or rows.
   */
  void _processPercentages(List<GridDef> defs, num availableLength) {
    // Process percentage sized columns.
    num totalPercent = 0.0;
    var totalFixedSize = 0.0;
    int lastDef = -1;
    int defCount = defs.length;
    for (int defIndex = 0; defIndex < defCount; defIndex++) {
      GridDef def = defs[defIndex];
      if (def.layoutType == LayoutType.PERCENT) {
        if (!def.lengthDefined) {
          totalPercent += 1.0;
        } else {
          totalPercent += def.length;
        }
        lastDef = defIndex;
      } else {
        totalFixedSize += def.minLayoutSize;
      }
    }
    _distributeExtraSpace(defs, availableLength, totalPercent,
        totalFixedSize, lastDef);
  }

  /**
   * Distributes extra space across columns that have percent based layout.
   *
   * @param defs Array of column or row definitions.
   * @param availableLength Total amount of space available.
   * @param totalPercent Total of percent values for all griddefs.
   * @param totalFixedSize Fixed size used by all rows or columns.
   * @param lastIndex Index of last row or column that has percent
   *  layout.
   */
  void _distributeExtraSpace(List<GridDef> defs, num availableLength,
      num totalPercent, num totalFixedSize, int lastIndex) {

    // If we have more available width than totalFixed minimum size,
    // distribute the extra amount to each percentage based column. To
    // eliminate rounding assign remainder to last column.
    int defCount = defs.length;
    if (availableLength > totalFixedSize) {
      num totalDistribAmount = (availableLength - totalFixedSize);
      num distribAmount = totalDistribAmount;
      for (int defIndex = 0; defIndex < defCount; defIndex++) {
        GridDef def = defs[defIndex];
        if (def.layoutType != LayoutType.PERCENT) {
          continue;
        }
        if (defIndex == lastIndex) {
          def.minLayoutSize = max(distribAmount, def.minLayoutSize);
        } else {
          num s = (def.length / totalPercent) * totalDistribAmount;
          def.minLayoutSize = max(s, def.minLayoutSize);
          distribAmount -= s;
        }
        def.layoutSize = def.minLayoutSize;
      }
    }
  }

  /**
   * Measures children and updates minimum sizes for auto and fixed sized
   * columns for fixed grid layout.
   * @param layoutType specifies what type of columns the update is performed
   *  on.
   */
  void _updateMinimumLayoutSize(int layoutType) {
    int numChildren = childCount;
    int rowIndex;
    int columnIndex;
    GridColumn column;
    GridRow row;

    for (int childIndex = 0; childIndex < numChildren; childIndex++) {
      UIElement child = childElements[childIndex];
      rowIndex = child.getProperty(rowProperty);
      columnIndex = child.getProperty(columnProperty);

      while (columnIndex >= _gridColumns.length) {
        _gridColumns.add(null);
      }
      if (_gridColumns[columnIndex] == null) {
        column = new GridColumn();
        _gridColumns[columnIndex] = column;
        column.initLayoutSizes();
      } else {
        column = _gridColumns[columnIndex];
      }

      while (rowIndex >= _gridRows.length) {
        _gridRows.add(null);
      }
      if (_gridRows[rowIndex] == null) {
        row = new GridRow();
        _gridRows[rowIndex] = row;
        row.initLayoutSizes();
      } else {
        row = _gridRows[rowIndex];
      }

      if ((column.layoutType & layoutType) != 0) {
        child.measure(column.layoutSize - (2 * _cachedCellPadding),
            row.layoutSize - (2 * _cachedCellPadding));
        column.minLayoutSize = max(column.minLayoutSize,
            child.measuredWidth + (_cachedCellPadding * 2));
        row.minLayoutSize = max(row.minLayoutSize, child.measuredHeight +
            _cachedCellPadding * 2);
      }
    }
    // Fill in empty rows and columns
    for (int fillIndex = 0; fillIndex < _gridRows.length; fillIndex++) {
      if (_gridRows[fillIndex] == null) {
        row = new GridRow();
        _gridRows[fillIndex] = row;
        row.initLayoutSizes();
      }
    }
    for (columnIndex = 0; columnIndex < _gridColumns.length; columnIndex++) {
      if (_gridColumns[columnIndex] == null) {
        column = new GridColumn();
        _gridColumns[columnIndex] = column;
        column.initLayoutSizes();
      }
    }
  }

  /**
   * Sets minLayoutSize based on a column or row's layout settings
   * such as minLength, maxLength, length and layout type. This step prepares
   * the column and row objects for measuring cell content size and later
   * applying percent based updates.
   */
  void _initLayoutSizes(List<GridDef> array) {
    int length = array.length;
    for (int index = 0; index < length; index++) {
      array[index].initLayoutSizes();
    }
  }

  /**
   * Returns row index of a child.
   */
  static int getChildRow(UIElement child) {
    return child.getProperty(rowProperty);
  }

  /**
   * Returns column index of a child.
   */
  static int getChildColumn(UIElement child) {
    return child.getProperty(columnProperty);
  }

  /**
   * Sets row index of a child.
   */
  static void setChildRow(UIElement child, int row) {
    child.setProperty(rowProperty, row);
  }

  /**
   * Sets column index of a child.
   */
  static void setChildColumn(UIElement child, int column) {
    child.setProperty(columnProperty, column);
  }


  /**
   * Handles changes to row and column attached properties.
   */
  static void _childLocationChangedHandler(UIElement target,
      PropertyDefinition property, Object oldValue, Object newValue) {
    // Child row/column setting has changed. If parent is a grid,
    // remeasure & layout.
    UIElement element = target;
    if (element.visualParent is Grid) {
      Grid grid = element.visualParent;
      grid.invalidateSizeForChild(element);
    }
  }

  /**
   * Handles row and column collection changes.
   */
  void _gridStructureChanged(CollectionChangedEvent changeEvent) {
    // Clear internal rows/column so they are regenerated.
    _gridRows = null;
    _gridColumns = null;
    invalidateSize();
  }

  void _gridDefChanged() {
    _gridDefsDirty = true;
    invalidateSize();
    invalidateLayout();
  }

  /** Registers component. */
  static void registerGrid() {
    rowProperty = ElementRegistry.registerProperty("row",
        PropertyType.INT, PropertyFlags.ATTACHED, _childLocationChangedHandler,
        0);
    columnProperty = ElementRegistry.registerProperty("column",
        PropertyType.INT, PropertyFlags.ATTACHED, _childLocationChangedHandler,
        0);
    cellPaddingProperty = ElementRegistry.registerProperty("cellPadding",
        PropertyType.NUMBER, PropertyFlags.RELAYOUT | PropertyFlags.RESIZE,
        null, 0.0);
    gridElementDef = ElementRegistry.register("Grid",
        UIElementContainer.uielementcontainerElementDef,
        [rowProperty, columnProperty, cellPaddingProperty], null);
  }

  /** @see UxmlElement.getDefinition. */
  ElementDef getDefinition() => gridElementDef;
}

class GridRows extends ElementCollection {
  GridRows() : super() {
  }
}

class GridColumns extends ElementCollection {
  GridColumns() : super() {
  }
}
